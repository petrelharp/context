# Results from fitting procedure

*Invocation:*
```{r, echo=FALSE}
library(pander)
library(ggplot2)
panderOptions("table.split.table", Inf)  # Let tables become arbitrarily wide rather than wrapping.
source("context-inference-fns.R")
top_n_bottom <- function(df, k) { # Take the top and bottom k rows
    n = nrow(df)
    if(2*k < n) {
        df[c(1:k,(n-(k-1)):n), ]
    }
    else {
        df
    }
}
counts_table <- function(in_longwin, in_shortwin, half_n_show) {
    if ( in_longwin > longwin(model@counts) || in_shortwin > shortwin(model@counts) ) {
        cat("Window size of counts too small.")
        return(NULL)
    }
    else {
        resids = computeresids(model,
                in_longwin=in_longwin,
                in_shortwin=in_shortwin,
                in_leftwin=floor((in_longwin-in_shortwin)/2),
                counts=model@counts)
        pandoc.table(top_n_bottom(resids, half_n_show), style="rmarkdown")
        return(invisible(resids))
    }
}
counts_plot <- function (resids) {
    if (NROW(resids)>0) { 
        hist(resids$z, xlab="z-score", ylab='') 
        outfac <- factor(resids$outpat)
        with(resids, plot(observed, expected, xlab='observed', ylab='expected', col=rainbow(nlevels(outfac))[as.numeric(outfac)], pch=20 ) )
        abline(0,1)
        with(resids, plot(observed, expected, xlab='observed', ylab='expected', log='xy', col=rainbow(nlevels(outfac))[as.numeric(outfac)], pch=20 ) )
        abline(0,1)
    }
}
cat(model@invocation,"\n")
```


## Details
```{r, include=FALSE}
# For some reason the code doesn't work if we don't print out some of the
# counts, but we can do it in a hidden block.
counttab <- counts(model)
```


```{r, echo=FALSE}
cat("left window size:", model@counts@leftwin,
    "\ncomplete window size:", nchar(rownames(counttab)[[1]]),
    "\ntotal counts:", sum(counttab),
    "\ntime:", simseq.opt$tlen,
    "\nseed:", formatC(simseq.opt$seed,format="d"),
    "\n"
    )
```


## Result of fitting operation
```{r, echo=FALSE}
if (class(model)=="context") {
    cat("convergence: ", model@results$convergence,
        "\nmessage: ", model@results$message,
        "\n" )
} else if (class(model)=="contextMCMC") {
    cat(
        "number of batches: ", model@results$nbatch,
        "\nbatch length: ", model@results$blen,
        "\nacceptance rate: ", model@results$accept,
        "\nrun time: ", model@results$time['elapsed'],
        "\n" )
}
```


## Fitted parameter values
```{r, echo=FALSE, results="asis"}
time <- as.numeric(simseq.opt$tlen)
mr_compare <- data.frame( 
    fit=c( model@mutrates / time, model@selcoef, model@params), 
    stringsAsFactors=FALSE )
simvalues <- data.frame(
        names=c(
            mutnames(simseq.config$tip$mutpats), 
            selnames(simseq.config$tip$selpats), 
            names(simseq.config$tip$fixfn.params) ),
        simulated=unlist(c(
            simseq.config$tip$mutrates,
            simseq.config$tip$selcoef,
            simseq.config$tip$fixfn.params ) )
)
mr_compare$simulated <- simvalues$simulated[match(rownames(mr_compare),simvalues$names)]
pandoc.table(mr_compare, style="rmarkdown")
```


The corresponding plot, where bars are the fit values, and points are the simulated values:
```{r, echo=FALSE, results="asis", fig.align='center'}
mr_compare$names <- factor(rownames(mr_compare), levels=rownames(mr_compare))
param_sizes <- floor(log10(abs(mr_compare$simulated)+1e-4)/2)
for (k in unique(param_sizes)) {
    print( ggplot(mr_compare[param_sizes==k,], aes(x=names)) + xlab("") +
        geom_bar(aes(y=fit), stat = "identity", fill="white", color="gray") +
        geom_point(aes(y=simulated)) +
        theme(axis.text.x = element_text(angle = 90),
              axis.title.y = element_blank())
      )
}
```


## residuals for 2-2 Tmers
```{r, echo=FALSE, results="asis", fig.align='center'}
resids <- counts_table(in_longwin=2, in_shortwin=2, half_n_show=20)
counts_plot(resids)
```

## residuals for 3-1 Tmers
```{r, results="asis", fig.align='center'}
resids <- counts_table(in_longwin=3, in_shortwin=1, half_n_show=20)
counts_plot(resids)
```

## residuals for 9-5 Tmers
```{r, results="asis", fig.align='center'}
resids <- counts_table(in_longwin=9, in_shortwin=5, half_n_show=20)
counts_plot(resids)
```

# Trace plot of the MCMC run:
```{r, results="asis", echo=FALSE, fig.width=12, fig.height=7, fig.align='center'}
if (class(model)=="contextMCMC") {
    subseq <- seq(1,nrow(model@results$batch),length.out=min(1000,nrow(model@results$batch)))
    x <- model@results$batch[subseq,]
    colnames(x) <- rownames(mr_compare)[model@results$use.par]
    param_sizes <- floor(log10(abs(mr_compare$simulated)+1e-4)/2)
    param_sizes <- param_sizes[model@results$use.par]
    for (k in unique(param_sizes)) {
        print( { 
            matplot( model@results$blen*subseq, x[,param_sizes==k], type='l', col=1:5, lty=1:6, xlab='number of MCMC iterations' )
            abline(h=mr_compare$simulated[model@results$use.par], col=1:5, lty=1:6)
            legend("topright",legend=colnames(x)[param_sizes==k],col=1:5,lty=1:6)
        } )
    }
} else {
    cat("Not an MCMC run.")
}
```

# Pairwise marginal posteriors from MCMC, colored by time in MCMC run
```{r, results="asis", echo=FALSE, fig.width=12, fig.height=12, fig.align='center'}
if (class(model)=="contextMCMC") {
    subseq <- seq(1,nrow(model@results$batch),length.out=min(1000,nrow(model@results$batch)))
    x <- rbind( model@results$batch[subseq,], mr_compare$simulated[model@results$use.par] ) 
    colnames(x) <- rownames(mr_compare)[model@results$use.par]
    # color by time
    cols <- c( adjustcolor(rainbow(64),.2)[1+floor(65*(1:(nrow(x)-1))/nrow(x))], adjustcolor("black",.5) )
    pairs( x, col=cols, pch=20, cex=c(rep(.5,nrow(x)-1),2), gap=0 )
} else {
    cat("Not an MCMC run.")
}
```
