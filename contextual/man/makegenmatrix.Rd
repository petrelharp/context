% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/genmatrix.R
\name{makegenmatrix}
\alias{makegenmatrix}
\alias{meangenmatrix}
\title{Make a Generator Matrix}
\usage{
makegenmatrix(mutpats, selpats = list(), patlen,
  patterns = getpatterns(patlen, bases), bases, fixfn, mutrates = rep(1,
  length(mutpats)), selcoef = rep(1, length(selpats)),
  selfactors = lapply(selpats, sapply, function(x) 1), boundary = "none",
  ...)

meangenmatrix(leftwin, rightwin, patlen, ...)
}
\arguments{
\item{mutpats}{List of mutation Tmer motifs.}

\item{selpats}{List of selection motifs.}

\item{patlen}{Length of the patterns that index rows and columns of the matrix.}

\item{patterns}{List of the patterns that index rows and columns of the matrix.}

\item{bases}{Alphabet used.}

\item{fixfn}{Fixation function.}

\item{mutrates}{Vector of mutation rates corresponding to mutpats.}

\item{selcoef}{Vector of selection coefficients corresponding to selpats.}

\item{selfactors}{List of numeric vectors of the same structure as selpats of relative selection coefficients.}

\item{boundary}{What to do with the boundary of the *patterns* ("none" or "wrap").}
}
\value{
A genmatrix object.
}
\description{
Make the generator matrix G on the specified set of patterns,
carrying with it the means to quickly update itself.
 DON'T do the diagonal (i.e. it must be left empty), so that the updating is easier.
}
\details{
Result is a superclass of column-oriented sparse matrices (see
?"dgCMatrix-class" and ?"CsparseMatrix-class"), for which the following
vectors implicitly index the vector @x that actually stores the entries:
  @i ; (0-based) row numbers of nonzero entries
  @p : (0-based) indices of the first nonzero entries in each column (so
        diff(x@p) gives the number of nonzero entries by column)



Here is what happens in makegenmatrix:

Let G be the generator matrix, i.e. G[i,j] is the instantaneous transition rate from patterns[i] to patterns[j].
Construct this as follows:
 For each mutation pattern u, let I(u) be the set of index pairs (i,j) such that patterns[i] -> patterns[j] can be obtained by applying u,
   ordered in some way, so I(u) = ( (i_1,j_1), (i_2,j_2), ..., (i_{n(u)},j_{n(u)}) ).
 Then let I_k be the concatenation of these lists for all mutation patterns in mutpats[[k]].
 Also, concatenate the I_k to form I.
 Note that the same pair (i,j) can occur in some I_k twice, or in different I_k,
   for instance if { C -> T } occurs at rate mutrates[1], and both { CG -> TG, CCG -> CTG } occur at rate mutrates[2],
   and patterns[1] == CCG, and patterns[23] == CTG, then the pair (1,23) would occur once in I_1 and twice in I_2.
 Now,
   G[i,j] = \sum_k mutrates[k] * ( number of times (i,j) appears in I_k ) .
 Let (x_1, ..., x_N) be the nonzero entries of G, in some order.
   and let f_m = (i_m,j_m) be the row,column index of x_m in G.
 We need to compute P so that x = P %*% mutrates, i.e. the N x length(mutpats) matrix
   P[m,k] = ( number of times f_m appears in I_k )
 To do this, also note that if we define the N x length(I) matrix
   Q[m,l] = 1 if the l-th element of I is equal to f_m, and 0 otherwise
 and the the length(I) x length(mutpats) matrix
   J[l,k] = 1 if the l-th element of I came from I_k, and 0 otherwise,
 then
   P = Q %*% J .
}
\section{Functions}{
\itemize{
\item \code{meangenmatrix}: Create a Generator Matrix Averaged Over Possible Boundary States
}}

\examples{
# XO -> OX at rate 3 and OX -> XO at rate 1:
G <- makegenmatrix( patlen=3, mutpats=list(list(c("XO","OX")),list(c("OX","XO"))), mutrates=c(3,1),
                selpats=list(), selfactors=list(), bases=c("X","O"), fixfn=function (...) { 1 } )
dim(G)
G
# with selection
G <- makegenmatrix( patlen=3, mutpats=list(list(c("XO", "OX")), list(c("OX", "XO"))), mutrates=c(3,1),
                selpats=list(c("XX","OO"),c("X")), selfactors=list(c(2,1),c(1)), selcoef=c(5,1),
                bases=c("X","O"), fixfn=function (...) { 1 } )
dim(G)
G

}
