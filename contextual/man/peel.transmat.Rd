% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/transition_matrix.R
\name{peel.transmat}
\alias{peel.transmat}
\alias{peel.transmat.setup}
\alias{peel.transmat.compute}
\title{Compute probabilities of all combinations, on a tree}
\usage{
peel.transmat(tree, rowtaxon, coltaxa, modelnames, genmatrices, projmatrix,
  root.distrn, tlens = tree$edge.length, return.list = TRUE,
  normalize = TRUE, debug = FALSE)

peel.transmat.setup(tree, rowtaxon, coltaxa, modelnames, genmatrices,
  projmatrix, tlens = tree$edge.length, return.list = FALSE,
  debug = FALSE)

peel.transmat.compute(setup, genmatrices, root.distrn, tlens, debug = FALSE,
  return.list = TRUE, normalize = TRUE)
}
\arguments{
\item{tree}{The tree.}

\item{rowtaxon}{The name of a single tip, or the root - that gets the 'long' patterns}

\item{coltaxa}{A vector of names of tips - these get 'short' patterns}

\item{modelnames}{A named character vector of model names, with one name for each node or tip of the tree.}

\item{genmatrices}{A list of genmatrix'es whose names are model names}

\item{projmatrix}{A projection matrix that moves from 'long' to 'short' pattern space}

\item{root.distrn}{A numeric vector of long pattern frequencies at the root}

\item{tlens}{Lengths of the tree's branches.}

\item{return.list}{Whether to return everything (default) or just the transition matrices}

\item{normalize}{Whether transition matrices on the path from the rowtaxon to the root
are conditional on the observed row pattern (see details).}

\item{debug}{Whether to keep around some extra information useful for
checking - in particular, row and column names on the resulting matrices.}
}
\value{
A list with the following components:

transmats - named by the terminal node of each branch, this gives the transition matrix describing
            the probability of seeing the patterns at those tips which this branch separates
            from the rowtaxon, given a long pattern at the end of this branch closest to the rowtaxon
up  - Gives indices of genmatrices and times for the "up" steps of the peeling algorithm
root - Same for the "turning around" step at the root
down - Same for moving back down towards the rowtaxon
final - Same for the final step connecting to the rowtaxon
tlens - Lengths of branches
tlens.ord - Unused
col.order - 
row.node - index of the node that corresponds to rows - transmats[[row.node]]
           is the transition matrix we are interested in
}
\description{
Does quite a bit of precomputation to figure out how to (re-)do this computation,
but if called with return.list=FALSE will only return the transition matrix
that matches with counts (possibly reordered using reorder.counts).

Figures out what order to do things in.

Compute probabilities of all combinations, on a tree
}
\details{
If `return.list` is TRUE (the default), the output can be used as `setup` to
subsequent calls to peel.transmat.compute(), saving on recomputation.

If `normalize` is FALSE then transition matrices *on the path from rowtaxon to the root*
give the *joint* probability of the row and column patterns.  This is not usually what
we want, because without conditioning on the longer end of the T-mer the probabilities
are not correct.  However, note that in computing the conditional probability of the sequences
given the rowtaxon sequence, either can be used (the answer will be the same).
}
\section{Functions}{
\itemize{
\item \code{peel.transmat.setup}: Set up computation for peel.transmat.compute

\item \code{peel.transmat.compute}: Compute transition matrices
}}

\examples{
# Fast evolution on the branches going to tip3 and the ancestor of (tip1,tip2); but slow on those two branches:
tree <- ape::read.tree(text="( (tip1 : 1.0, tip2 : 1.0) node1 : 0.5, tip3 : 1.5 ) root;")
G1 <- makegenmatrix( patlen=3, mutpats=list(list(c("XO","OX")),list(c("OX","XO"))), mutrates=c(10,10),
                selpats=list(), selfactors=list(), bases=c("X","O"), fixfn=function (...) { 1 } )
G2 <- makegenmatrix( patlen=3, mutpats=list(list(c("XO","OX")),list(c("OX","XO"))), mutrates=c(0.1,0.1),
                selpats=list(), selfactors=list(), bases=c("X","O"), fixfn=function (...) { 1 } )
genmatrices <- list(fast=G1, slow=G2)
projmatrix <- collapsepatmatrix(rownames(G1), leftwin=1, shortwin=1, bases=c("X","O"))
transmat <- peel.transmat(tree, rowtaxon="tip1", coltaxa=c("tip2","tip3"), 
                             modelnames=c(tip1="slow", tip2="slow", tip3="fast", node1="fast"), 
                             genmatrices=genmatrices, projmatrix=projmatrix,
                             root.distrn=rep(1/8,length=8), debug=TRUE, return.list=FALSE )
range(rowSums(transmat)) # all equal 1

# unconditioned
raw.transmat <- peel.transmat(tree, rowtaxon="tip1", coltaxa=c("tip2","tip3"), 
                             modelnames=c(tip1="slow", tip2="slow", tip3="fast", node1="fast"), 
                             genmatrices=genmatrices, projmatrix=projmatrix,
                             root.distrn=rep(1/8,length=8), debug=TRUE, return.list=FALSE,
                             normalize=FALSE )
sum(raw.transmat) # equals 1

}
